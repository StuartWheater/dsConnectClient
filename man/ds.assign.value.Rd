% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ds.assign.value.R
\name{ds.assign.value}
\alias{ds.assign.value}
\title{Assign some values on some DataSHIELD servers}
\usage{
ds.assign.value(
  new.variable.name = NULL,
  value = NULL,
  class.type = NULL,
  asynchronous = FALSE,
  error.stop = TRUE,
  datasources = NULL
)
}
\arguments{
\item{new.variable.name}{a character string specifying 
the name of a new variable created on a server}

\item{value}{the name of a column in a data repositories or 
an R expression allowed to assign function calls}

\item{class.type}{a character string stating the R internal type. \cr
Correct values:
\itemize{
\item "\code{\link{NULL}}"
\item "\code{\link{character}}"
\item "\code{\link{complex}}"
\item  "\code{\link{factor}}"
\item "\code{\link{double}}"
\item "\code{\link{expression}}"
\item "\code{\link{integer}}"
\item "\code{\link{list}}"
\item "\code{\link{matrix}}"
\item "\code{\link{logical}}"
\item "\code{\link{numeric}}"
\item "\code{\link{single}}"
\item "\code{\link{vector}}"
\item  "\code{\link{S4}}"
\item "\code{\link{environment}}"
\item "\code{RangedSummarizedExperiment}"
\item "\code{SummarizedExperiment}"
\item "\code{ExpressionSet}"
}}

\item{asynchronous}{logical. If TRUE, the calls are parallelized over the connections. 
If FALSE no parallelisation occurs. Default TRUE.}

\item{error.stop}{a logical value to stop the code execution (TRUE) or not (FALSE)}

\item{datasources}{a list of \code{DSConnection-class} objects obtained after login.}
}
\value{
\itemize{
\item TRUE if the values have been created in all the servers. 
\item FALSE if the values have not been successfully created on all the servers
}
}
\description{
Assign a table or an expression result to an R variable, 
within a DataSHIELD R session on at least one server.
}
\details{
\itemize{
\item \code{ds.assign.value} captures any errors and warnings 
thrown by the function \code{.assign}. No error or warning is displayed. 
If an error or a warning is caught, then the function returns FALSE.
\item \code{.assign} wraps the function \code{DSI::datashield.assign}. 
A valid OpalConnection, a valid server variable name and value is checked. 
When  all these conditions are met, then a server call is made. 
}
Both functions can be used interchangeably. 
\code{.assign} allows more efficient debugging of some server and client code. 
\code{ds.assign.value} can be used 
once the code is efficiently working.
}
\examples{
\dontrun{

  ## Version 6.2, for older versions see the Wiki
  # Connecting to the Opal servers

  # Load necessary client packages
  require('DSI')
  require('DSOpal')
  require('dsBaseClient')
  require('dsConnectClient')

  # Append login information for a specific server
  
    #Data computers name
    server.names   <- c("Paris", "Newcastle", "New York")
    
    # Data computers url
    url_Paris     <- 'https://192.168.56.100:8443'
    url_Newcastle <- 'https://192.168.56.100:8443'
    url_NewYork   <-  'https://192.168.56.100:8443'
    server.urls     <- c(url_Paris,url_Newcastle,url_NewYork)
    
    # Assign datasets
    table_Paris     <- "TESTING.DATASET1"
    table_Newcastle <- "TESTING.DATASET2"
    table_NewYork   <- "TESTING.DATASET3"
    server.tables   <- c(table_Paris, table_Newcastle, table_NewYork)

    # Set user and password to access the DataSHIELD servers
    user_Paris      <-  "administrator"
    user_Newcastle  <-  "administrator"
    user_NewYork    <-  "administrator"
    server.users.id <- c(user_Paris, user_Newcastle, user_NewYork)

    password_Paris      <-  "datashield_test&"
    password_Newcastle  <-  "datashield_test&"
    password_NewYork    <-  "datashield_test&"
    server.users.pwd    <-  c(password_Paris, password_Newcastle, password_NewYork)
    
    # Set drivers
    driver_Paris     <- "OpalDriver"
    driver_Newcastle <- "OpalDriver"
    driver_NewYork   <- "OpalDriver"
    server.drivers   <- c(driver_Paris,driver_Newcastle,driver_NewYork)

    # Set SSL drivers
    ssl_options_Paris     <- "list(ssl_verifyhost=0,ssl_verifypeer=0)"
    ssl_options_Newcastle <- "list(ssl_verifyhost=0,ssl_verifypeer=0)"
    ssl_options_NewYork   <- "list(ssl_verifyhost=0,ssl_verifypeer=0)"
    server.ssl.options    <- c(ssl_options_Paris,ssl_options_Newcastle,ssl_options_NewYork)
      
    # Create login data frame
    login.data <- ds.build.login.data.frame(server.names,
                                            server.urls,
                                            server.tables,
                                            server.users.id,
                                            server.users.pwd,
                                            server.ssl.options,
                                            server.drivers)
  # Log in to DataSHIELD server                                         
  connections <- ds.login(login.data.frame = login.data, assign = TRUE, symbol = "D")
  
  # Assign some values in the server-side
  
  ds.assign.value(new.variable.name = "new_var",
                  value = "D$INTEGER", 
                  class.type = "integer", 
                  datasources = connections)
           
  # Clear the Datashield/R sessions and logout
  ds.logout(connections) 
}
}
\seealso{
\code{DSI::datashield.assign}

\code{ds.exists.on.server}
}
\author{
Patricia Ryser-Welch for DataSHIELD development team
}
